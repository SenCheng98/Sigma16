; CondCode: test the condition code
; This file is part of Sigma16; see README, https://jtod.github.io/home/Sigma16/
; John O'Donnell, 2021

; Condition code flags are defined in architecture.mjs
; The code display characters are sSCVv <L=G>
; CC bit index definitions:
; export const bit_ccg = 0   //  >  greater than integer (two's complement)
; export const bit_ccG = 1   //  G  greater than natural (binary)
; export const bit_ccE = 2   //  =  equal all types
; export const bit_ccL = 3   //  L  less than natural (binary)
; export const bit_ccl = 4   //  <  less than integer (two's complement)

; export const bit_ccv = 5   //  v  overflow integer (two's complement)
; export const bit_ccV = 6   //  V  overflow natural (binary)
; export const bit_ccC = 7   //  C  carry propagation natural (binary)
; export const bit_ccS = 8;  //  S  stack overflow
; export const bit_ccs = 9;  //  s  stack underflow

; Test data
      lea   R1,3[R0]    ; 0003  R1 := 3
      lea   R2,5[R0]    ; 0005  R2 := 5
      lea   R3,-3[R0]   ; fffd  R3 := -2
      lea   R4,-7[R0]   ; fff9  R4 := -7

; Compare two positives
      cmp    R1,R2      ; 0018  <L  lt signed, lt unsigned
      cmp    R2,R1      ; 0003  G>  gt signed, gt unsigned

; Compare positive and negative
      cmp    R2,R3      ; 0009  L>  gt signed, lt unsigned
      cmp    R3,R2      ; 0012  <G  lt signed, gt unsigned

; Compare two negatives
      cmp    R3,R4      ; 0003  G>  gt signed, gt unsigned
      cmp    R4,R3      ; 0018  <L  lt signed, lt unsigned

; Addition
      add    R5,R1,R2   ; 0001  >   8 is positive
      add    R5,R2,R4   ; 0010  <   -2 is negative
      add    R5,R1,R3   ; 0002  -   0 is zero

      lea     R1,-30000[R0]    ; R1 = I: -30000   N: 8ad0
      lea     R2,-2[R0]        ; R2 = I:     -2   N: fffe
      lea     R3,13[R0]        ; R3 = I:     13   N: 000d
      lea     R4,28749[R0]     ; R4 = I:  28749   N: 704d

      cmp     R0,R0     ; =
      cmp     R0,R1     ; > L
      cmp     R0,R2     ; > L
      cmp     R0,R3     ; < L
      cmp     R0,R4     ; < L

      cmp     R1,R0     ; < G
      cmp     R1,R1     ; =
      cmp     R1,R2     ; < L
      cmp     R1,R3     ; < G
      cmp     R1,R4     ; < G
      cmp     R2,R0     ; < G
      cmp     R2,R1     ; > G
      cmp     R2,R2     ; =
      cmp     R2,R3     ; < G
      cmp     R2,R4     ; < G

      cmp     R3,R0     ; > G
      cmp     R3,R1     ; > L
      cmp     R3,R2     ; > L
      cmp     R3,R3     ; =
      cmp     R3,R4     ; < L

      cmp     R4,R0     ; > G
      cmp     R4,R1     ; > L
      cmp     R4,R2     ; > L
      cmp     R4,R3     ; > G
      cmp     R4,R4     ; =
      trap    R0,R0,R0
