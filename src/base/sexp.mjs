// Sigma16: sexp.mjs
// Copyright (C) 2022 John T. O'Donnell
// email: john.t.odonnell9@gmail.com
// License: GNU GPL Version 3 or later. See Sigma16/README.md, LICENSE.txt

// This file is part of Sigma16.  Sigma16 is free software: you can
// redistribute it and/or modify it under the terms of the GNU General
// Public License as published by the Free Software Foundation, either
// version 3 of the License, or (at your option) any later version.
// Sigma16 is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.  You should have received
// a copy of the GNU General Public License along with Sigma16.  If
// not, see <https://www.gnu.org/licenses/>.

//------------------------------------------------------------------------
// S-expressions
//------------------------------------------------------------------------

import * as com from './common.mjs';
import * as arith from './arithmetic.mjs';

//----------------------------------------------------------------------
// Primitive data structures
//----------------------------------------------------------------------

// A list is either an Atom or a Cons cell.  These are represented as
// objects that are generated by classes.  Every list has a field
// 'atomic' which is true for Atoms and false for cons cells.

class Atom {
    constructor (str) {
        this.atomic = true
        this.atomstring = str
    }
    show () {
        return this.atomstring
    }
}

class Cons {
    constructor (car, cdr) {
        this.atomic = false
        this.car = car
        this.cdr = cdr
    }
    show () {
        return '(' + this.car.show() + ' . ' + this.cdr.show() + ')'
    }
}

//----------------------------------------------------------------------
// The heap
//----------------------------------------------------------------------

// The Cons constructor uses the JavaScript virtual machine to
// allocate a cell.  Currently the cons function uses that, and the
// program relies on the JavaScript virtual machine's garbage
// collector.  An alternative to consider is to initialzie the system
// by building an explicit avail list, and to use its own garbage
// collector.  That would be more complex, and might be slower (or
// conceivable faster), but it would make it easier to limit the
// amount of memory allocation and could give more graceful failure if
// a program allocates too much.  This is a point to examine in more
// depth later.

//----------------------------------------------------------------------
// Primitive functions
//----------------------------------------------------------------------

// Functions to create an atom and cons cell.  Atom strings are not
// currently interned; consider that for later.  Currently, each atom
// has a separate copy of its string.

function atom (str) {
    return new Atom (str)
}

function cons (x,y) {
    return new Cons (x,y)
}

function atomp (x) {
    return x.atomic
}

function nullp (x) {
    return x === nil
}

// Global names for basic atoms.

let nil = atom ('nil')
let err = atom ('Error')
let eof = atom ('EOF')

// Since atoms are not interned, eq needs to compare the strings.

function eq (x,y) {
    return (x == y)
        || (x.atomic && y.atomic && x.atomstring == y.atomstring)
}

function car (x) {
    if (x.atomic) {
        console.log (`error: car applied to atom ${x.show}`)
        return err
    } else {
        return x.car
    }
}

function rplaca (x,y) {
    if (x.atomic) {
        console.log (`error: rplaca applied to atom ${x.show}`)
        return err
    } else {
        x.car = y
        return x
    }
}

function cdr (x) {
    if (x.atomic) {
        console.log (`error: cdr applied to atom ${x.show}`)
        return err
    } else {
        return x.cdr
    }
}

function rplacd (x,y) {
    if (x.atomic) {
        console.log (`error: rplacd applied to atom ${x.show}`)
        return err
    } else {
        x.cdr = y
        return x
    }
}

//----------------------------------------------------------------------
// lexer
//----------------------------------------------------------------------

let inputTokens =
    [ "abc",
      "pqr",
      ".",
      ")",
      "hello",
      "(", "a", "b", "c", ")",
      "(", "w", "x", "(", "p", "q", ")", "y", "z", ")",
      "nil",
      "end" ]

function getToken () {
    if (inputTokens.length == 0) {
        return eof
    } else {
        return inputTokens.shift()
    }
}

function lookToken () {
    if (inputTokens.length == 0) {
        return eof
    } else {
        return inputTokens[0]
    }
}

// temp stub; possibly replace this with regular expression test
function isSymbol (tok) {
    let a = tok[0]
    return a != '(' && a != ')' && a != '.'
}

function testGetToken () {
    console.log ('testGetToken')
    console.log (lookToken())
    console.log (lookToken())
    console.log (getToken())
    console.log (lookToken())
    console.log (getToken())
    console.log (getToken())
    console.log (getToken())
    console.log (isSymbol ('abc'))
    console.log (isSymbol ('('))
    console.log (isSymbol (')'))
    console.log (isSymbol ('.'))
    console.log (isSymbol (';'))
}

//----------------------------------------------------------------------
// parser
//----------------------------------------------------------------------


function error(msg) {
    console.log (`error: ${msg}`)
    return nil
}

function readsexp () {
    let t = getToken ()
    let result = nil
//    console.log (`readsexp: t = ${t}`)
    if (isSymbol(t)) {
        result = atom(t)
    } else if (t == "(") {
//        console.log ("readsexp: handling left paren")
        let head = cons (nil,nil)
        let last = head
        let x = nil
        let newCell = nil
        while (lookToken() != ")") {
            x = readsexp()
//            console.log (`readsexp: x=${x.show()}`)
            newCell = cons (x,nil)
            rplacd (last,newCell)
            last = newCell
        }
        let rp = getToken()
        if (rp == ")") {
            result = cdr(head)
        } else {
            error ("list doesn't end in right parenthesis")
        }
    } else if (t == ")") {
        error ("readsexp: unexpected right paren")
    } else if (t == ".") {
        error ("readsexp: unexpected dot")
    } else {
        error ("readsexp: unexpected token ${t}")
    }
//    console.log (`reasexp: returning ${result.show()}`)
    return result
}

function printSexp (x) {
    let str = ""
    if (atomp(x)) {
        str = x.show()
    } else {
        str = "("
        while (!nullp(x)) {
            str = str + printSexp (car(x)) + " "
            if (atomp(cdr(x)) && !nullp(cdr(x))) {
                str = str + " . " + cdr(x).show()
                x = nil
            } else {
                x = cdr(x)
            }
        }
        str = str + ")"
    }
    return str
}

//----------------------------------------------------------------------
// Examples and unit testing
//----------------------------------------------------------------------

function unitTest () {
    console.log ("Start unit testing")

    testGetToken()
    
    // atoms
    let x = new Atom("abc")
    let y = new Atom ("def")
    console.log (x.show())
    console.log (y.show())
    console.log (eq (x,x))
    console.log (eq (x,y))

    // z and w are equal but not eq
    let z = new Cons (x,y)
    let w = new Cons (x,y)
    console.log (z.show())
    console.log (w.show())
    console.log (eq (z,z))
    console.log (eq (z,w))

    // ztwo is eq to z
    let ztwo = z
    console.log ('ztwo is eq to z')
    console.log (ztwo.show())

    console.log (w.show())
    console.log (eq(ztwo,w))
    
    // but ztwo is not eq to w
    console.log ('ztwo is not eq to w')
    console.log (ztwo.show())
    console.log (z.show())
    console.log (eq(ztwo,z))

    // dotted pair
    let dp = cons (atom('a1'), atom('a2'))
    console.log (dp.show())

    // list of atoms
    let lat = cons (atom ('a'),
                    cons (atom('b'),
                          cons (atom('c'), nil)))
    console.log (lat.show())
    console.log ("End unit testing")
}

// Run the testing
// unitTest ()

function readShow () {
    let x = readsexp ()
    console.log (`readShow: ${x.show()}`)
    console.log (`${printSexp(x)}\n`)
}

console.log (nullp(nil))
console.log (nullp (atom("abc")))
console.log (nullp (cons(nil,nil)))

readShow()
readShow()
readShow()
readShow()
readShow()
readShow()
readShow()

