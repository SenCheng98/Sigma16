// Sigma16: sexp.mjs
// Copyright (C) 2022 John T. O'Donnell
// email: john.t.odonnell9@gmail.com
// License: GNU GPL Version 3 or later. See Sigma16/README.md, LICENSE.txt

// This file is part of Sigma16.  Sigma16 is free software: you can
// redistribute it and/or modify it under the terms of the GNU General
// Public License as published by the Free Software Foundation, either
// version 3 of the License, or (at your option) any later version.
// Sigma16 is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.  You should have received
// a copy of the GNU General Public License along with Sigma16.  If
// not, see <https://www.gnu.org/licenses/>.

//------------------------------------------------------------------------
// S-expressions
//------------------------------------------------------------------------

import * as com from './common.mjs';
import * as arith from './arithmetic.mjs';

//----------------------------------------------------------------------
// Primitive data structures
//----------------------------------------------------------------------

// A list is either an Atom or a Cons cell.  These are represented as
// objects that are generated by classes.  Every list has a field
// 'atomic' which is true for Atoms and false for cons cells.

class Atom {
    constructor (str) {
        this.atomic = true
        this.atomstring = str
    }
    show () {
        return this.atomstring
    }
}

class Cons {
    constructor (car, cdr) {
        this.atomic = false
        this.car = car
        this.cdr = cdr
    }
    show () {
        return '(' + this.car.show() + ' . ' + this.cdr.show() + ')'
    }
}

//----------------------------------------------------------------------
// The heap
//----------------------------------------------------------------------

// The Cons constructor uses the JavaScript virtual machine to
// allocate a cell.  Currently the cons function uses that, and the
// program relies on the JavaScript virtual machine's garbage
// collector.  An alternative to consider is to initialzie the system
// by building an explicit avail list, and to use its own garbage
// collector.  That would be more complex, and might be slower (or
// conceivable faster), but it would make it easier to limit the
// amount of memory allocation and could give more graceful failure if
// a program allocates too much.  This is a point to examine in more
// depth later.

//----------------------------------------------------------------------
// Primitive functions
//----------------------------------------------------------------------

// Functions to create an atom and cons cell.  Atom strings are not
// currently interned; consider that for later.  Currently, each atom
// has a separate copy of its string.

function atom (str) {
    return new Atom (str)
}

function cons (x,y) {
    return new Cons (x,y)
}

// Global names for basic atoms.

let nil = atom ('nil')
let err = atom ('Error')

// Since atoms are not interned, eq needs to compare the strings.

function eq (x,y) {
    return (x == y)
        || (x.atomic && y.atomic && x.atomstring == y.atomstring)
}

function car (x) {
    if (x.atomic) {
        console.log (`error: car applied to atom ${x.show}`)
        return err
    } else {
        return x.car
    }
}

function rplaca (x,y) {
    if (x.atomic) {
        console.log (`error: rplaca applied to atom ${x.show}`)
        return err
    } else {
        x.car = y
        return x
    }
}

function cdr (x) {
    if (x.atomic) {
        console.log (`error: cdr applied to atom ${x.show}`)
        return err
    } else {
        return x.cdr
    }
}

function rplacd (x,y) {
    if (x.atomic) {
        console.log (`error: rplacd applied to atom ${x.show}`)
        return err
    } else {
        x.cdr = y
        return x
    }
}

//----------------------------------------------------------------------
// read
//----------------------------------------------------------------------

let inputTokens =
    [ "abc",
      "(", "a", "b", "c", ")",
      "(", "w", "x", "(", "p", "q", ")", "y", "z", ")",
      "nil",
      "(", ")",
      "end" ]

function gettoken () {
    if (inputTokens.length == 0) {
        return eof
    } else {
        let x = inputTokens
    }
    
}

function readsexp () {
    let t = gettoken ()
    
}

//----------------------------------------------------------------------
// Examples and unit testing
//----------------------------------------------------------------------

function unitTest () {
    console.log ("Start unit testing")
    
    // atoms
    let x = new Atom("abc")
    let y = new Atom ("def")
    console.log (x.show())
    console.log (y.show())
    console.log (eq (x,x))
    console.log (eq (x,y))

    // z and w are equal but not eq
    let z = new Cons (x,y)
    let w = new Cons (x,y)
    console.log (z.show())
    console.log (w.show())
    console.log (eq (z,z))
    console.log (eq (z,w))

    // ztwo is eq to z
    let ztwo = z
    console.log ('ztwo is eq to z')
    console.log (ztwo.show())
    console.log (w.show())
    console.log (eq(ztwo,w))
    
    // but ztwo is not eq to w
    console.log ('ztwo is not eq to w')
    console.log (ztwo.show())
    console.log (z.show())
    console.log (eq(ztwo,z))

    // dotted pair
    let dp = cons (atom('a1'), atom('a2'))
    console.log (dp.show())

    // list of atoms
    let lat = cons (atom ('a'),
                    cons (atom('b'),
                          cons (atom('c'), nil)))
    console.log (lat.show())
    console.log ("End unit testing")
}

// Run the testing
unitTest ()
