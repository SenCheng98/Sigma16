% Created 2021-10-07 Thu 19:53
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{John T. O'Donnell}
\date{\today}
\title{The M1 Processor Circuit for Sigma16}
\hypersetup{
 pdfauthor={John T. O'Donnell},
 pdftitle={The M1 Processor Circuit for Sigma16},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.2 (Org mode 9.4.4)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Quick start}
\label{sec:orgf4224c8}

\begin{verbatim}
$ cd circuits
$ ghci
ghci> :load M1/Run
ghci> :main programs/Add
Sigma16.M1> run
Sigma16.M1> quit
ghci> :quit
\end{verbatim}

\section{Introduction}
\label{sec:org123fdb7}

Sigma16 is a computer architecture designed for research and teaching
in computer systems.  M1 is a CPU: it is a digital circuit that
executes the Core subset of Sigma16.

M1 is a synchronous circuit designed at the level of logic gates and
flip flops.  It is specified using the Hydra hardware description
language, which describes precisely the components and how they are
connected, and which can simulate the circuit.

The Circuit directory contains the M1 circuit, which is organized as
several subsystems.  The Run module defines a simulation driver; this
is a command line text interface that provides human readable inputs
and outputs.  The ReadObj module is used to boot the system: it reads
an object code file produced by the Sigma16 assembler and
automatically generates the inputs required to make the circuit boot
the program.


\section{Running the system}
\label{sec:org4f15872}

\subsection{Installation}
\label{sec:org7ad5d3a}

\begin{itemize}
\item Install ghc
\item Install Hydra
\end{itemize}

\subsection{Configuration}
\label{sec:org78ee250}

There is a directory \texttt{circuits/programs} which contains several
Sigma16 programs.  The examples below use these programs, and you can
put your own programs there too.  If you do so, you can skip this
section.

However, you may wish to keep the circuits directory and your Sigma16
programs directory in different locations in your file system.  If you
do that, you may end up with long file paths to your object code, and
this can make it hard to type in the command to load a program.  The
M1 driver has a facility to make that easier.

If the file \texttt{circuits/fileprefix.txt} exists, then the text in its
first line is attached to the beginning of the file specified in the
argument to the \texttt{:main} command.  For example, suppose the full path
to your object code file is
\texttt{/some/long/path/to/your/code/MyProgram.obj.txt}.  Then you can put
\texttt{/some/long/path/to/your/code/} into \texttt{fileprefix.txt}, and then
run the program with just \texttt{:main MyProgram}.

If you don't want anything prefixed to your file arguments, either set
fileprefix.txt to a blank line, or simply delete it.

\subsection{An example program}
\label{sec:org1853d9b}

Before examining the circuit, let's begin by taking a Sigma16 assembly
language program and running it on the circuit.  This is
\texttt{circuits/programs/Add.asm.txt}:

\begin{verbatim}
; Add: a minimal program that adds two integer variables
; This file is part of Sigma16; see README and https://jtod.github.io/home/Sigma16/

; Execution starts at location 0, where the first instruction will be
; placed when the program is executed.

      load   R1,x[R0]   ; R1 := x
      load   R2,y[R0]   ; R2 := y
      add    R3,R1,R2   ; R3 := x + y
      store  R3,z[R0]   ; z := x + y
      trap   R0,R0,R0   ; terminate

; Expected result: z = x + y = 23 + 14 = 37 (hex 0025)

; Static variables are placed in memory after the program

x     data  23
y     data  14
z     data   0
\end{verbatim}

\subsection{Assemble the program}
\label{sec:org94a495b}

Computers don't run assembly language, they run machine language.  So
we need to translate the program.  There are several ways to do this:

\begin{itemize}
\item \emph{Command.} If you have installed the Sigma16 tools on youc computer,
enter this command: \texttt{sigma16 assemble programs/Add}
\item \emph{Sigma16 app.} Launch Sigma16, load the example program, assemble
it, and save the object code in a file.  The file must be named
\texttt{Add.obj.txt}
\item \emph{Assemble it by hand.}  It's important to know \emph{how} to assemble a
program by hand, and it's worth doing one or two times.  But
once you understand how to translate from assembly to machine
language, it's better to use the software tools.
\end{itemize}

\subsection{Run the machine code on the M1 circuit}
\label{sec:orga8861eb}

Now you can run the machine language program \texttt{Add.obj.txt} on the
circuit:

\begin{itemize}
\item \emph{Enter the circuits directory.} \texttt{\$ cd Sigma16/src/circuits} The ghci
command must be executed in this directory.
\item \emph{Launch Haskell.}  \texttt{\$ ghci}
\item \emph{Launch Hydra and M1.} \texttt{ghci> :load M1/Run}
\item \emph{Load the machine language program.} \texttt{ghci> :main programs/Add}
\item \emph{Boot the program and run it on the circuit.} \texttt{Sigma16.M1> run}
\item \emph{Leave M1 driver.}  \texttt{Sigma16.M1> quit}
\item \emph{Leave ghci.} \texttt{ghci> :quit}
\end{itemize}

\subsection{Breakpoints}
\label{sec:org272c6e7}

The machine may exectue many clock cycles before it reaches a state
that you're interested in.  For example, if you want to examine
exactly how the circuit executes a jal instruction, you need to get
through the boot process and then all the instructions that execute
before the jal.  This can take a long time, and you may have to do it
repeatedly.

The M1 simulation driver provides \emph{breakpoints} which alleviate this
problem.  The idea is that you specify that a bit signal of interest
is a breakpoint.  Then when you enter a run command, it will perform
clock cycles repeatedly until the breakpoint signal becomes 1.  At
that point the simulation stops and you can examine the machine state
in detail, and single step (or run) from that point on.

several t
When you start the system (e.g. :main Arrays/ArrayMax) it will take a
log of clock cycles to boot the machine language program.  If there
are n words of instructions and data, it will take n clock cycles.
It's useful to enter these commands:

\begin{verbatim}
break reset
run
\end{verbatim}

This will run the simulation without stopping, until the reset signal
becomes 1, and then it will stop.  That way you can start single
stepping through the program, but don't have to single step through
the boot.

\subsection{Reference: prompts and commands}
\label{sec:org9182d3c}

Prompts
\begin{verbatim}
$             is the bash shell prompt
 ghci:        is the ghci prompt
 Sigma16.M1>  is the circuit prompt
\end{verbatim}

Useful ghci commands (see ghc User Guide for full documentationO
\begin{verbatim}
$          is the bash shell prompt
:r         reload after editing any of the code
:q         exit ghci, go back to shell
^C         stop and return to ghci prompt
uparrow    repeat previous command
\end{verbatim}


\section{Datapath}
\label{sec:org89ea49c}

The datapath of a processor contains the registers, the circuits that
perform calculations (ALU and functional units), and the buses that
connect them.  All of these subsystems take control inputs that
determine their behavior.  Those control signals are generated by the
control system, which is not part of the datapath.

\subsection{ALU}
\label{sec:org2ff0a37}

The ALU (arithmetic and logic unit) is a combinational circuit that
performs calculations which can be completed efficiently in one clock
cycle.  The ALU performs integer additions, subtractions, comparisons,
and the the like.  However, more complex operations, such as
multiplication, division, and all floating point operations, require
more than one clock cycle.  They also require some additional state
(registers), and are typically performed in functional units.


The ALU calculates a function of word inputs x and y (which are
usually the contents of two registers) and cc (the contents of R15).
It produces a word output r, which is a numeric result (typically
loaded into the destination register), and a comparison result ccnew
which is the new value to be loaded into the condition code register.
The ALU performs addition, subtraction, negation, increment, and
comparision.  The function is determined by two control signals (alua,
alub).

Furthermore, the ALU receives ir\textsubscript{d} as an input and uses it to output
cond, which is the bit in cc indexed by ir\textsubscript{d}.  This is used by jumpc0
and jumpc1.

Control inputs:
\begin{itemize}
\item alua, alub
\end{itemize}
Data inputs:
\begin{itemize}
\item x
\item y
\item cc
\item ir\textsubscript{d}
\end{itemize}
Data outputs:
\begin{itemize}
\item r      = function (a,b) x y cc
\item ccnew  = compare x y cc
\item cond   = R15.ir\textsubscript{d}  (use ir\textsubscript{d} to select bit from condition code)
\end{itemize}

The data output r is the result of an arithmetic operation which
is determinted by the control inputs:


op = (alua, alub,  aluc)

\begin{center}
\begin{tabular}{ll}
a b c & r\\
\hline
0 0 0 & x+y\\
0 0 1 & x-y\\
0 1 0 & -x\\
0 1 1 & x+1\\
1 0 0 & cmp\\
\end{tabular}
\end{center}

The control algorithm defines all control signals, regardless of what
operation is being performed.


Sigma16 defines the following condition code flags.

\begin{center}
\begin{tabular}{rll}
bit index & Relation & Symbol\\
\hline
0 & > Int & g\\
1 & > Nat & G\\
2 & = & =\\
3 & < Nat & L\\
4 & < Int & <\\
5 & Int overflow & v\\
6 & Nat overflow & V\\
7 & Carry & C\\
8 & Stack overflow & S\\
9 & Stack underflow & s\\
\end{tabular}
\end{center}


\begin{verbatim}
alu n (alua,alub,aluc) x y cc d = (sum, ccnew, cond)
  where
    negating = and2 (inv alua) (xor2 alub aluc)  -- alu abc = 001 or 010
    arith = inv alua  -- doing arithmetic operation, alu abc one of 000 001 010 100
    comparing = and3 alua (inv alub) (inv aluc)  -- doing comparison, alu abc = 100
    wzero = fanout n zero
    wone = boolword n one
-- prepare inputs to adder    
    x' = mux2w (alub,aluc) x x wzero x
    y' = mux2w (alub,aluc) y (invw y) (invw x) wone
    xy = bitslice2 x' y'
    (carry,sum) = rippleAdd negating xy
-- binary comparison    
    (lt,eq,gt) = rippleCmp xy
-- two's complement comparison    
    lt_tc = mux2 (xy!!0) lt zero one lt
    eq_tc = eq
    gt_tc = mux2 (xy!!0) gt one zero gt
-- carry and overflow
    natovfl = carry
    intovfl = zero -- ????
-- condition code flags
    fcarry = and2 carry (inv comparing)
    fnatovfl = and2 natovfl (inv comparing)
    fintovfl = and2 intovfl (inv comparing)
    ccnew = [ zero,   zero,     zero,     zero,   -- bit 15 14 13 12
              zero,   zero,     zero,     zero,   -- bit 11 10  9  8
              fcarry, fnatovfl, fintovfl, lt_tc,  -- bit  7  6  5  4
              lt,     eq,       gt,       gt_tc   -- bit  3  2  1  0
            ]
-- conditional bit controls conditional jumps            
    cond = indexbit d cc
\end{verbatim}

-- indexbitcs xs: select element at index cs from xs, where index 0 is
-- least significant position; require that length xs = 2 \^{} length cs

indexbit :: Bit a => [a] -> [a] -> a
indexbit [] [x] = x
indexbit (c:cs) xs =
  mux1 c (indexbit cs (drop i xs))
         (indexbit cs (take i xs))
  where i = 2 \^{} length cs

-- mux4 cs xs: select element at index cs from xs; require that length
-- xs = 2 \^{} length cs

muxw :: Bit a => [a] -> [a] -> a
muxw [] [x] = x
muxw (c:cs) xs =
  mux1 c (muxw cs (take i xs))
         (muxw cs (drop i xs))
  where i = 2 \^{} length cs


\subsubsection{Condition codes}
\label{sec:org6c98e44}


\begin{verbatim}
--    comparing = and3 a b (or2 c d)
--    comp_bool = mux2 (c,d) zero lt_tc eq_tc gt_tc
--    comp_word = boolword n comp_bool
--    z = mux1w comparing sum comp_word
\end{verbatim}


\subsection{Basic register file}
\label{sec:org8779f76}

\begin{verbatim}
regfile1
  :: CBit a   -- sequential circuit with signal type a
  => Int      -- k is number of reg address bits, with 2^k registers
  -> a        -- ld.  if ld then reg[d] := x
  -> [a]      -- d is destination address, register to load
  -> [a]      -- sa is source address a, first operand to fetch
  -> [a]      -- sb is source address b, second operand to fetch
  -> a        -- x is data to load into reg[d] if ld=1
  -> (a,a)    -- (reg[sa], reg[sb]) is the readouts of two registers
\end{verbatim}

\begin{verbatim}
regfile1 k ld d sa sb x
  | k==0 = (r,r)
  | k>0  = (a,b)
  where
    r = reg1 ld x
    (a0,b0) = regfile1 (k-1) ld0 ds sas sbs x
    (a1,b1) = regfile1 (k-1) ld1 ds sas sbs x
    (ld0,ld1) = demux1 d1 ld
    a = mux1 sa1 a0 a1
    b = mux1 sb1 b0 b1
    (d1:ds) = d
    (sa1:sas) = sa
    (sb1:sbs) = sb
\end{verbatim}

The regfile1 circuit has \(2^{k}\) words, each consisting of 1 bit.  A
full register file with \$n\$-bit words simply consists of \(n\) copies of
the regfile1 circuit.

\begin{verbatim}
regfile :: CBit a => Int -> Int
  -> a -> [a] -> [a] -> [a] -> [a] -> ([a],[a])
regfile n k ld d sa sb x =
   unbitslice2 [regfile1 k ld d sa sb (x!!i)  | i <- [0..n-1]]
\end{verbatim}


\subsection{Handling R0 and R15}
\label{sec:org0f3e9d7}

The basic register file treats all registers the same.  However,
Sigma16 treats R0 and R15 as special cases:

\begin{itemize}
\item R0 is always 0.  It is legal to load another value into it, but any
readout of R0 will yield 0.

\item R15 is the condition code.  It holds the result of the cmp
instruction.  Furthermore, arithmetic instructions (which place
their result in the register specified by \texttt{Reg[ir\_d]}) also set some
flags in the condition code indicating overflow and other
conditions.  The conditional jump instructions automatically fetch
bits from R15.
\end{itemize}

There are several ways the circuit could handle R0.  M1 uses the best
approach: R0 does not actully have any flip flops.  A load into R0 is
simply discarded, and the combinational logic for fetching a register
produces the value 0 when R0 is fetched.  This approach is  relatively
simple to implement, and the resulting circuit consumes less power and
requires less chip area than alternatives that use flip flops to  hold
the irrelevant state of R0.

R15, which holds the condition code, is more complex.  There are two
reasons:
\begin{itemize}
\item The machine may need to read out both R15 and some other register at
the same time.
\item The machine may need to load a new value into both R15 and some
other register at the same time.
\end{itemize}

Both of these requirements cannot be satisfied with the basic register
file circuit.  Instead, it would be necessary to use two clock cycles.

It would be possible to handle the condition code by using two clock
cycles for arithmetic instructionss, one to put the result into the
destination register and another to put the condition code into R15.
However, add instructions are frequently executed, and this would give
an unacceptable slowdown.  (The M1 circuit is designed to be as simple
as possible, but more advanced circuits should be possible with the
architecture.)

It is critically important to be able

Register file with special treatment of R0 and R15

\begin{itemize}
\item reg[0] always outputs 0
\item reg[15] is always output, and can be loaded independently from other registers
\end{itemize}

Effect on state (from programmer's perspective)
\begin{itemize}
\item if ld                   then reg[d] := x
\item if \textasciitilde{}(ld \& d=15) \& ldcc  then reg[15] := xcc
\end{itemize}

State update (from perspective of circuit)
\begin{itemize}
\item reg[0] there is no state
\item reg[d] for 0 < d < 15:  reg[d] := if ld then x else reg[d]
\item reg[15] :=
\end{itemize}

\begin{verbatim}
if ld & d=15 then x
else if ldcc then xcc
else reg[15]
\end{verbatim}


\begin{verbatim}
Inputs
  ld     load control
  ldcc   load into R15
  x      data input
  xcc    R15 data input
  d      destination address
  sa     source a address
  sb     source b address

Outputs
  a = reg[sa]
  b = reg[sb]
  cc = reg[15]
\end{verbatim}

\subsection{Implementing the register file with special cases}
\label{sec:orgd5c7fdb}

Recursion is controlled by the addresses; if their lengths vary there
will be a pattern match error

RFspan determines how to generate the circuit for the base cases

\begin{verbatim}
data RFspan
  = RFfull      -- contains R0
  | RFhead       -- contains R15
  | RFtail       -- contains R15
  | RFinside     -- contains neither R0 nor R15
\end{verbatim}

\begin{verbatim}
headType, tailType :: RFspan -> RFspan
headType RFfull   = RFhead
headType RFinside = RFinside
headType RFhead   = RFhead
headType RFtail   = RFinside

tailType RFfull   = RFtail
tailType RFinside = RFinside
tailType RFhead   = RFinside
tailType RFtail   = RFtail
\end{verbatim}

-- 1-bit Register file with special cases for lowest and highest
-- indices (R0, cc).  Sigma16 uses 4-bit addresses for d, sa, sb,
-- leading to 16 registers, where the special cases are R0 (the head,
-- i.e. lowest address) and R15 (the tail, i.e. highest address)

\begin{verbatim}
regFileSpec1
  :: CBit a
  => RFspan
  -> a           -- ld: if ld then reg[d] := x
  -> a           -- ldcc: if ldcc then reg[15] := xcc (but ld R15 takes precedence)
  -> [a]         -- d: destination address
  -> [a]         -- sa: source a address
  -> [a]         -- sb: source b address
  -> a           -- x = data input for reg[d]
  -> a           -- xcc = data input for condition code R15
  -> (a,a,a)     -- (reg[sa], reg[sb], reg[15])
\end{verbatim}

-- Recursion is based on the address words.  There will be a pattern
-- match error if the addresses (d, sa, sb) don't all have the same
-- number of bits.  There will also be a pattern match error if the
-- base case has RFtype = RFfull, as a singleton register cannot be
-- both R0 and R15.

-- Base cases

\begin{verbatim}
regFileSpec1 RFinside ld ldcc [] [] [] x xcc = (r,r,zero)
  where r = reg1 ld x
regFileSpec1 RFhead ld ldcc [] [] [] x xcc = (zero,zero,zero)
regFileSpec1 RFtail ld ldcc [] [] [] x xcc = (r,r,r)
  where r = reg1 (or2 ld ldcc) (mux1 ld xcc x)
\end{verbatim}

-- Recursion case

\begin{verbatim}
regFileSpec1 rft ld ldcc (d:ds) (sa:sas) (sb:sbs) x xcc = (a,b,cc)
  where (a0,b0,cc0) = regFileSpec1 (headType rft) ld0 ldcc ds sas sbs x xcc
        (a1,b1,cc1) = regFileSpec1 (tailType rft) ld1 ldcc ds sas sbs x xcc
        (ld0,ld1) = demux1 d ld
        a = mux1 sa a0 a1
        b = mux1 sb b0 b1
        cc = cc1
\end{verbatim}

-- n-bit register file with special cases for R0 and R15

\begin{verbatim}
regFileSpec
  :: CBit a
  => Int             -- word size
  -> a               -- ld: if ld then reg[d] := x
  -> a               -- ldcc: load R15
  -> [a]             -- d: destination address
  -> [a]             -- sa: source a address
  -> [a]             -- sb: source b address
  -> [a]             -- x = data input for reg[d]
  -> [a]             -- xcc = data input for condition code R15
  -> ([a],[a],[a])  -- (reg[sa], reg[sb], reg[15])
\end{verbatim}

\begin{verbatim}
regFileSpec n ld ldcc d sa sb x xcc =
  unbitslice3 [regFileSpec1 RFfull ld ldcc d sa sb (x!!i) (xcc!!i)
                 | i <- [0 .. n - 1]]
\end{verbatim}


\section{Control}
\label{sec:orgd158294}
\subsection{Control state: basic delay elements}
\label{sec:org87adaae}

\begin{verbatim}
st_a = dff ...
st_b = dff st_a
st_c = dff st_b
st_d = dff st_c
...
\end{verbatim}

\begin{verbatim}
st_dispatch = dff ...
ps = demux4 op st_a

st_a0 = dff (ps!!0)  -- op=0000 indicates operation a
st_a1 = dff st_a0
st_a2 = dff st_a1

st_b0 = dff (ps!!1)  -- op=0001 indicates operation b
st_b1 = dff st_a0
st_b2 = dff st_a1

st_c0 = dff (ps!!2)  -- op=0010 indicates operation b
st_c1 = dff st_c0
st_c2 = dff st_c1
...

st_z0 = dff (ps!!15)  -- op=1111 indicates operation z
st_z1 = dff st_z0
st_z2 = dff st_z1
...
\end{verbatim}

\subsection{Basic delay elemeent method for control}
\label{sec:orgd5100f6}

There are many ways to synthesize a control circuit from a control
algorithm.  A simple approach is the delay element method.

For example, consider the chain of states for the load instruction.
In the basic delay element method (which doesn't provide for DMA cycle
stealing), the states would be defined like this, and The control
signals are generated directly from those states:

\begin{verbatim}
dff_load0 = dff (pRX!!1)
dff_load1 = dff st_load0
dff_load2 = dff st_load1
\end{verbatim}

The control signals are generated by the states.  For example, suppose
\begin{itemize}
\item State \texttt{dff\_load0} asserts \texttt{c1} and \texttt{c2}
\item State \texttt{load1} asserts \texttt{c3}
\item State \texttt{load2} asserts \texttt{1c} and \texttt{c3}
\end{itemize}
Then the controls are defined by
\begin{itemize}
\item =c1 = orw [dff=load0, dff\textsubscript{load2}]
\item =c2 = orw [dff\textsubscript{load1}]
\item =c3 = orw [dff\textsubscript{load0}, dff\textsubscript{load2}]
\end{itemize}


\subsection{Enhanced delay elements for DMA and cycle stealing}
\label{sec:org648e636}

Direct memory access (DMA) is a method for supporting Input/Output.
An input operation requires data from an input device to be stored
into the memory.  An output operation is the reverse: data must be
fetched from memory and sent to an output device.

One way to implement I/O is to require the CPU to perform the memory
accesses during an I/O operation.  This method was actually used on
some very early computers (1940s), but it is extremely slow, and is
not used on modern computers.

DMA is far more efficient.  The idea is that the processor doesn't
access the memory for I/O.  Instead, it makes a request for input or
output; this means simply sending a small message to the I/O system.
The I/O system then performs its own accesses to the memory.

For example ``print 80 characters in memory starting at address
2bc3''.  Sigma16 makes this request using a trap instruction: trap
R1,R2,R3 specifies the operation by a number in R1, and arguments in
R2 and R3.  For example, if R1 contains 1 (the trap code for write),
thhis tells the I/O system to print the contents of memory starting at
the address in R2, and the number of characters is given in R3.

The main technical issue in DMA is that both the processor and the I/O
system are making accesses to the memory, and these are likely to
happen at the same time.  The memory itself, however, can do only one
operation at a time.  Therefore it is necessary to ensure that the
processor and I/O do not interfere with each other.

Suppose the I/O controller needs to fetch a memory location x.  To do
so, the system needs to set some control signals, and place x on the
memory address control.  But these actions could interfere with normal
execution of the processor.  If the processor happens to be accessing
memory at some other address, there will be a conflict.

How can we resolve a confliict between the I/O system and the
processor when both want to access memory at the same time?  There are
two general approaches: cycle stealing and a separate memory
management unit.  The M1 system uses cycle stealing.

The idea behind cycle stealing is that during every clock cycle,
either the processor or the memory is performing an action, but never
both.  In this context, ``action'' means changing the state by putting
new values into the flip flops.

The main system controller provides a signal DMA that indicates
whether the processor or the I/O can perform a memory operation during
the current cycle.  If DMA is 0 the processor should operate
normally.  If DMA is 1 the I/O system can access the memory, and the
CPU should leave its state unchanged at the next clock tick.

In the basic delay element method, the system will definitly set all
the control signals corresponding to the current state.  However, we
need to
\begin{itemize}
\item Set all the processor's control signals to 0 during a cycle when DMA=1.
\item Leave the control state unchanged at the next clock tick.  That
enables the processor to retry its current operation in the next
clock cycle.
\end{itemize}


To achieve this, two signals are defined for every state: a flip flop
which represents ``the processor is trying to be in this statee,
unless the cycle has been stolen'', and a logic signal that means
``the processor is in charge this cycle and is actually generating
control signals''.

This 
To support cycle stealing, there is a dff for each state
(e.g. \texttt{dff\_load0}) and an additional signal (\texttt{st\_load0}) that is 1 if
the flip flip is 1 and the cycle is not stolen.  If \texttt{dff\_load0} is 1
it means that the processor needs to execute this state.  If
\texttt{st\_load0} is 1 it means the processor actually is in this state and
its control signals can be asserted.

\begin{verbatim}
dff_load0 = dff (or2 (pRX!!1) (and2 dff_load0 io_DMA))
st_load0  = and2 dff_load0 cpu
dff_load1 = dff (or2 st_load0 (and2 dff_load1 io_DMA))
st_load1  = and2 cpu dff_load1
dff_load2 = dff (or2 st_load1 (and2 dff_load2 io_DMA))
st_load2  = and2 cpu dff_load2
\end{verbatim}

Suppose \texttt{io\_DNA} is 0 for a  number of clock cycles, and the machine
is dispatching an instruction with secondary opcide 1.  That indicates
a \texttt{load} instruction, and .  Consider what happens during
a sequence of clock cycles.
\begin{itemize}
\item Suppose that during cycle 100 \texttt{pRX!!1} is 1.
\item Cycle 101
\begin{itemize}
\item At the clock tick beginning the cycle, \texttt{dff\_load0} will become 1
\item Suppose that during cycle 101, \texttt{io\_DMA} is 1, so \texttt{cpu} is 1.
Since \texttt{dff\_load0} is 1, \texttt{st\_load0} is also 1, and the control
signals for the \texttt{load0} state will all be 1.  The processor will
perform the first step of the \texttt{load} instruction.  What that
really means is that any flip flop changes required will occur st
the clock tick that ends Cycle 101 and begins cycle 102.
\end{itemize}
\item Cycle 102
\begin{itemize}
\item At the clock tick between cycles 101 and 102, \texttt{dff\_load1} becomes
1 and \texttt{dff\_load0} becomes 0.
\item But suppose that the  I/O system needs to steal the cycle to do
its own memory access.  To do this, the system sets \texttt{io\_DNA} = 1m
and that makes \texttt{cpu} = 0.
\item Although \texttt{dff\_load1} = 1, the corresponding signal \texttt{st\_load1} is 0
during this cycle.  This is because \texttt{st\_load1 = and2 cpu
    dff\_load1} and the value of \texttt{cpu} is 0.  Consequently, the control
signals set byy \texttt{st\_load1} all remain 0.  Any register updates
belonging to \texttt{st=load1} will not happen at the next clock tick.
Notice that all the cominbational logic calculations for
\texttt{st\_load1} will go ahead; but their results will not be latched
into any register at the clock tick.  These logic calculations
will be repeated during the next clock cycle.
\item Because the processor will not update any registers at the end of
the cycle, it is safe for the I/O to set the controls for the
memory that it needs, as well as the memory address and data words.
\item At the clock tick ending this cycle, the I/O memory access takes
place and the processor does nothing: its cycle has been stolen.
\end{itemize}
\item 
\end{itemize}

\section{System}
\label{sec:orgc1afc92}
\end{document}
